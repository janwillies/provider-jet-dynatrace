/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationTypeComparisonObservation struct {
}

type ApplicationTypeComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be APPLICATION_TYPE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ApplicationTypeObservation struct {
}

type ApplicationTypeParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AzureComputeModeComparisonObservation struct {
}

type AzureComputeModeComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are DEDICATED or SHARED.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AzureComputeModeObservation struct {
}

type AzureComputeModeParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are DEDICATED or SHARED.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AzureSkuComparisionObservation struct {
}

type AzureSkuComparisionParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be AZURE_SKU
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AzureSkuObservation struct {
}

type AzureSkuParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type BaseComparisonBasicObservation struct {
}

type BaseComparisonBasicParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The type of comparison
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type BaseConditionKeyObservation struct {
}

type BaseConditionKeyParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// Defines the actual set of fields depending on the value
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type BitnessComparisionObservation struct {
}

type BitnessComparisionParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be BITNESS
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are 32 and 64.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type BitnessObservation struct {
}

type BitnessParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are 32 and 64.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type CloudTypeComparisonObservation struct {
}

type CloudTypeComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be CLOUD_TYPE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type CloudTypeObservation struct {
}

type CloudTypeParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ComparisonObservation struct {
}

type ComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The type of comparison
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type ConditionObservation struct {
}

type ConditionParameters struct {

	// The reference value for comparison. For conditions of the `DIMENSION` type, specify the key here
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// How to compare. Possible values are
	// - `BEGINS_WITH`
	// - `EQUALS`
	// +kubebuilder:validation:Required
	Match *string `json:"match" tf:"match,omitempty"`

	// The type of the condition. Possible values are
	// - `DIMENSION`
	// - `LOG_FILE_NAME`
	// - `METRIC_KEY`
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value of the dimension. Only applicable when type is set to `DIMENSION`
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ConditionsObservation struct {
}

type ConditionsParameters struct {

	// Comparison for `APPLICATION_TYPE` attributes
	// +kubebuilder:validation:Optional
	ApplicationType []ApplicationTypeParameters `json:"applicationType,omitempty" tf:"application_type,omitempty"`

	// Comparison for `APPLICATION_TYPE` attributes
	// +kubebuilder:validation:Optional
	ApplicationTypeComparison []ApplicationTypeComparisonParameters `json:"applicationTypeComparison,omitempty" tf:"application_type_comparison,omitempty"`

	// Comparison for `AZURE_COMPUTE_MODE` attributes
	// +kubebuilder:validation:Optional
	AzureComputeMode []AzureComputeModeParameters `json:"azureComputeMode,omitempty" tf:"azure_compute_mode,omitempty"`

	// Comparison for `AZURE_COMPUTE_MODE` attributes
	// +kubebuilder:validation:Optional
	AzureComputeModeComparison []AzureComputeModeComparisonParameters `json:"azureComputeModeComparison,omitempty" tf:"azure_compute_mode_comparison,omitempty"`

	// Comparison for `AZURE_SKU` attributes
	// +kubebuilder:validation:Optional
	AzureSku []AzureSkuParameters `json:"azureSku,omitempty" tf:"azure_sku,omitempty"`

	// Comparison for `AZURE_SKU` attributes
	// +kubebuilder:validation:Optional
	AzureSkuComparision []AzureSkuComparisionParameters `json:"azureSkuComparision,omitempty" tf:"azure_sku_comparision,omitempty"`

	// A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
	// +kubebuilder:validation:Optional
	BaseComparisonBasic []BaseComparisonBasicParameters `json:"baseComparisonBasic,omitempty" tf:"base_comparison_basic,omitempty"`

	// Fallback for not yet known type
	// +kubebuilder:validation:Optional
	BaseConditionKey []BaseConditionKeyParameters `json:"baseConditionKey,omitempty" tf:"base_condition_key,omitempty"`

	// Comparison for `BITNESS` attributes
	// +kubebuilder:validation:Optional
	Bitness []BitnessParameters `json:"bitness,omitempty" tf:"bitness,omitempty"`

	// Comparison for `BITNESS` attributes
	// +kubebuilder:validation:Optional
	BitnessComparision []BitnessComparisionParameters `json:"bitnessComparision,omitempty" tf:"bitness_comparision,omitempty"`

	// Comparison for `CLOUD_TYPE` attributes
	// +kubebuilder:validation:Optional
	CloudType []CloudTypeParameters `json:"cloudType,omitempty" tf:"cloud_type,omitempty"`

	// Comparison for `CLOUD_TYPE` attributes
	// +kubebuilder:validation:Optional
	CloudTypeComparison []CloudTypeComparisonParameters `json:"cloudTypeComparison,omitempty" tf:"cloud_type_comparison,omitempty"`

	// A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
	// +kubebuilder:validation:Optional
	Comparison []ComparisonParameters `json:"comparison,omitempty" tf:"comparison,omitempty"`

	// Comparison for `CUSTOM_APPLICATION_TYPE` attributes
	// +kubebuilder:validation:Optional
	CustomApplicationType []CustomApplicationTypeParameters `json:"customApplicationType,omitempty" tf:"custom_application_type,omitempty"`

	// Comparison for `CUSTOM_APPLICATION_TYPE` attributes
	// +kubebuilder:validation:Optional
	CustomApplicationTypeComparison []CustomApplicationTypeComparisonParameters `json:"customApplicationTypeComparison,omitempty" tf:"custom_application_type_comparison,omitempty"`

	// Key for Custom Host Metadata
	// +kubebuilder:validation:Optional
	CustomHostMetadata []CustomHostMetadataParameters `json:"customHostMetadata,omitempty" tf:"custom_host_metadata,omitempty"`

	// Key for Custom Host Metadata
	// +kubebuilder:validation:Optional
	CustomHostMetadataConditionKey []CustomHostMetadataConditionKeyParameters `json:"customHostMetadataConditionKey,omitempty" tf:"custom_host_metadata_condition_key,omitempty"`

	// Key for Custom Process Metadata
	// +kubebuilder:validation:Optional
	CustomProcessMetadata []CustomProcessMetadataParameters `json:"customProcessMetadata,omitempty" tf:"custom_process_metadata,omitempty"`

	// Key for Custom Process Metadata
	// +kubebuilder:validation:Optional
	CustomProcessMetadataConditionKey []CustomProcessMetadataConditionKeyParameters `json:"customProcessMetadataConditionKey,omitempty" tf:"custom_process_metadata_condition_key,omitempty"`

	// Comparison for `DATABASE_TOPOLOGY` attributes
	// +kubebuilder:validation:Optional
	DatabaseTopology []DatabaseTopologyParameters `json:"databaseTopology,omitempty" tf:"database_topology,omitempty"`

	// Comparison for `DATABASE_TOPOLOGY` attributes
	// +kubebuilder:validation:Optional
	DatabaseTopologyComparison []DatabaseTopologyComparisonParameters `json:"databaseTopologyComparison,omitempty" tf:"database_topology_comparison,omitempty"`

	// Comparison for `DCRUM_DECODER_TYPE` attributes
	// +kubebuilder:validation:Optional
	DcrumDecoder []DcrumDecoderParameters `json:"dcrumDecoder,omitempty" tf:"dcrum_decoder,omitempty"`

	// Comparison for `DCRUM_DECODER_TYPE` attributes
	// +kubebuilder:validation:Optional
	DcrumDecoderComparison []DcrumDecoderComparisonParameters `json:"dcrumDecoderComparison,omitempty" tf:"dcrum_decoder_comparison,omitempty"`

	// Comparison for `ENTITY_ID` attributes
	// +kubebuilder:validation:Optional
	Entity []EntityParameters `json:"entity,omitempty" tf:"entity,omitempty"`

	// Comparison for `ENTITY_ID` attributes
	// +kubebuilder:validation:Optional
	EntityIDComparison []EntityIDComparisonParameters `json:"entityIdComparison,omitempty" tf:"entity_id_comparison,omitempty"`

	// Comparison for `SIMPLE_HOST_TECH` attributes
	// +kubebuilder:validation:Optional
	HostTech []HostTechParameters `json:"hostTech,omitempty" tf:"host_tech,omitempty"`

	// Comparison for `HYPERVISOR_TYPE` attributes
	// +kubebuilder:validation:Optional
	Hypervisor []HypervisorParameters `json:"hypervisor,omitempty" tf:"hypervisor,omitempty"`

	// `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
	// +kubebuilder:validation:Optional
	HypervisorTypeComparision []HypervisorTypeComparisionParameters `json:"hypervisorTypeComparision,omitempty" tf:"hypervisor_type_comparision,omitempty"`

	// Comparison for `INDEXED_NAME` attributes
	// +kubebuilder:validation:Optional
	IndexedName []IndexedNameParameters `json:"indexedName,omitempty" tf:"indexed_name,omitempty"`

	// Comparison for `INDEXED_NAME` attributes
	// +kubebuilder:validation:Optional
	IndexedNameComparison []IndexedNameComparisonParameters `json:"indexedNameComparison,omitempty" tf:"indexed_name_comparison,omitempty"`

	// Comparison for `INDEXED_STRING` attributes
	// +kubebuilder:validation:Optional
	IndexedString []IndexedStringParameters `json:"indexedString,omitempty" tf:"indexed_string,omitempty"`

	// Comparison for `INDEXED_STRING` attributes
	// +kubebuilder:validation:Optional
	IndexedStringComparison []IndexedStringComparisonParameters `json:"indexedStringComparison,omitempty" tf:"indexed_string_comparison,omitempty"`

	// Comparison for `INDEXED_TAG` attributes
	// +kubebuilder:validation:Optional
	IndexedTag []IndexedTagParameters `json:"indexedTag,omitempty" tf:"indexed_tag,omitempty"`

	// Comparison for `INDEXED_TAG` attributes
	// +kubebuilder:validation:Optional
	IndexedTagComparison []IndexedTagComparisonParameters `json:"indexedTagComparison,omitempty" tf:"indexed_tag_comparison,omitempty"`

	// Comparison for `INTEGER` attributes
	// +kubebuilder:validation:Optional
	Integer []IntegerParameters `json:"integer,omitempty" tf:"integer,omitempty"`

	// Comparison for `INTEGER` attributes
	// +kubebuilder:validation:Optional
	IntegerComparison []IntegerComparisonParameters `json:"integerComparison,omitempty" tf:"integer_comparison,omitempty"`

	// Comparison for `IP_ADDRESS` attributes
	// +kubebuilder:validation:Optional
	Ipaddress []IpaddressParameters `json:"ipaddress,omitempty" tf:"ipaddress,omitempty"`

	// Comparison for `IP_ADDRESS` attributes
	// +kubebuilder:validation:Optional
	IpaddressComparison []IpaddressComparisonParameters `json:"ipaddressComparison,omitempty" tf:"ipaddress_comparison,omitempty"`

	// Fallback for not yet known type
	// +kubebuilder:validation:Optional
	Key []KeyParameters `json:"key,omitempty" tf:"key,omitempty"`

	// Comparison for `MOBILE_PLATFORM` attributes
	// +kubebuilder:validation:Optional
	MobilePlatform []MobilePlatformParameters `json:"mobilePlatform,omitempty" tf:"mobile_platform,omitempty"`

	// Comparison for `MOBILE_PLATFORM` attributes
	// +kubebuilder:validation:Optional
	MobilePlatformComparison []MobilePlatformComparisonParameters `json:"mobilePlatformComparison,omitempty" tf:"mobile_platform_comparison,omitempty"`

	// Comparison for `OS_ARCHITECTURE` attributes
	// +kubebuilder:validation:Optional
	OsArch []OsArchParameters `json:"osArch,omitempty" tf:"os_arch,omitempty"`

	// Comparison for `OS_TYPE` attributes
	// +kubebuilder:validation:Optional
	OsType []OsTypeParameters `json:"osType,omitempty" tf:"os_type,omitempty"`

	// Comparison for `OS_ARCHITECTURE` attributes
	// +kubebuilder:validation:Optional
	OsarchitectureComparison []OsarchitectureComparisonParameters `json:"osarchitectureComparison,omitempty" tf:"osarchitecture_comparison,omitempty"`

	// Comparison for `OS_TYPE` attributes
	// +kubebuilder:validation:Optional
	OstypeComparison []OstypeComparisonParameters `json:"ostypeComparison,omitempty" tf:"ostype_comparison,omitempty"`

	// Comparison for `PAAS_TYPE` attributes
	// +kubebuilder:validation:Optional
	PaasType []PaasTypeParameters `json:"paasType,omitempty" tf:"paas_type,omitempty"`

	// Comparison for `PAAS_TYPE` attributes
	// +kubebuilder:validation:Optional
	PaasTypeComparison []PaasTypeComparisonParameters `json:"paasTypeComparison,omitempty" tf:"paas_type_comparison,omitempty"`

	// The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
	// +kubebuilder:validation:Optional
	ProcessMetadata []ProcessMetadataParameters `json:"processMetadata,omitempty" tf:"process_metadata,omitempty"`

	// The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
	// +kubebuilder:validation:Optional
	ProcessMetadataConditionKey []ProcessMetadataConditionKeyParameters `json:"processMetadataConditionKey,omitempty" tf:"process_metadata_condition_key,omitempty"`

	// Comparison for `SERVICE_TOPOLOGY` attributes
	// +kubebuilder:validation:Optional
	ServiceTopology []ServiceTopologyParameters `json:"serviceTopology,omitempty" tf:"service_topology,omitempty"`

	// Comparison for `SERVICE_TOPOLOGY` attributes
	// +kubebuilder:validation:Optional
	ServiceTopologyComparison []ServiceTopologyComparisonParameters `json:"serviceTopologyComparison,omitempty" tf:"service_topology_comparison,omitempty"`

	// Comparison for `SERVICE_TYPE` attributes
	// +kubebuilder:validation:Optional
	ServiceType []ServiceTypeParameters `json:"serviceType,omitempty" tf:"service_type,omitempty"`

	// Comparison for `SERVICE_TYPE` attributes
	// +kubebuilder:validation:Optional
	ServiceTypeComparison []ServiceTypeComparisonParameters `json:"serviceTypeComparison,omitempty" tf:"service_type_comparison,omitempty"`

	// Comparison for `SIMPLE_HOST_TECH` attributes
	// +kubebuilder:validation:Optional
	SimpleHostTechComparison []SimpleHostTechComparisonParameters `json:"simpleHostTechComparison,omitempty" tf:"simple_host_tech_comparison,omitempty"`

	// Comparison for `SIMPLE_TECH` attributes
	// +kubebuilder:validation:Optional
	SimpleTechComparison []SimpleTechComparisonParameters `json:"simpleTechComparison,omitempty" tf:"simple_tech_comparison,omitempty"`

	// Comparison for `STRING` attributes
	// +kubebuilder:validation:Optional
	String []StringParameters `json:"string,omitempty" tf:"string,omitempty"`

	// Comparison for `STRING` attributes
	// +kubebuilder:validation:Optional
	StringComparison []StringComparisonParameters `json:"stringComparison,omitempty" tf:"string_comparison,omitempty"`

	// The key for dynamic attributes of the `STRING` type
	// +kubebuilder:validation:Optional
	StringConditionKey []StringConditionKeyParameters `json:"stringConditionKey,omitempty" tf:"string_condition_key,omitempty"`

	// The key for dynamic attributes of the `STRING` type
	// +kubebuilder:validation:Optional
	StringKey []StringKeyParameters `json:"stringKey,omitempty" tf:"string_key,omitempty"`

	// Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
	// +kubebuilder:validation:Optional
	SyntheticEngine []SyntheticEngineParameters `json:"syntheticEngine,omitempty" tf:"synthetic_engine,omitempty"`

	// Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
	// +kubebuilder:validation:Optional
	SyntheticEngineTypeComparison []SyntheticEngineTypeComparisonParameters `json:"syntheticEngineTypeComparison,omitempty" tf:"synthetic_engine_type_comparison,omitempty"`

	// Comparison for `TAG` attributes
	// +kubebuilder:validation:Optional
	Tag []TagParameters `json:"tag,omitempty" tf:"tag,omitempty"`

	// Comparison for `TAG` attributes
	// +kubebuilder:validation:Optional
	TagComparison []TagComparisonParameters `json:"tagComparison,omitempty" tf:"tag_comparison,omitempty"`

	// Comparison for `SIMPLE_TECH` attributes
	// +kubebuilder:validation:Optional
	Tech []TechParameters `json:"tech,omitempty" tf:"tech,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type CustomApplicationTypeComparisonObservation struct {
}

type CustomApplicationTypeComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be CUSTOM_APPLICATION_TYPE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type CustomApplicationTypeObservation struct {
}

type CustomApplicationTypeParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type CustomHostMetadataConditionKeyDynamicKeyObservation struct {
}

type CustomHostMetadataConditionKeyDynamicKeyParameters struct {

	// The actual key of the custom metadata
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
	// +kubebuilder:validation:Required
	Source *string `json:"source" tf:"source,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type CustomHostMetadataConditionKeyObservation struct {
}

type CustomHostMetadataConditionKeyParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	// +kubebuilder:validation:Required
	DynamicKey []CustomHostMetadataConditionKeyDynamicKeyParameters `json:"dynamicKey" tf:"dynamic_key,omitempty"`

	// if specified, needs to be HOST_CUSTOM_METADATA_KEY
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type CustomHostMetadataObservation struct {
}

type CustomHostMetadataParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	// +kubebuilder:validation:Required
	DynamicKey []DynamicKeyParameters `json:"dynamicKey" tf:"dynamic_key,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type CustomProcessMetadataConditionKeyDynamicKeyObservation struct {
}

type CustomProcessMetadataConditionKeyDynamicKeyParameters struct {

	// The actual key of the custom metadata
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
	// +kubebuilder:validation:Required
	Source *string `json:"source" tf:"source,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type CustomProcessMetadataConditionKeyObservation struct {
}

type CustomProcessMetadataConditionKeyParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	// +kubebuilder:validation:Required
	DynamicKey []CustomProcessMetadataConditionKeyDynamicKeyParameters `json:"dynamicKey" tf:"dynamic_key,omitempty"`

	// if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type CustomProcessMetadataDynamicKeyObservation struct {
}

type CustomProcessMetadataDynamicKeyParameters struct {

	// The actual key of the custom metadata
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
	// +kubebuilder:validation:Required
	Source *string `json:"source" tf:"source,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type CustomProcessMetadataObservation struct {
}

type CustomProcessMetadataParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	// +kubebuilder:validation:Required
	DynamicKey []CustomProcessMetadataDynamicKeyParameters `json:"dynamicKey" tf:"dynamic_key,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type DatabaseTopologyComparisonObservation struct {
}

type DatabaseTopologyComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be DATABASE_TOPOLOGY
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type DatabaseTopologyObservation struct {
}

type DatabaseTopologyParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type DcrumDecoderComparisonObservation struct {
}

type DcrumDecoderComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be DCRUM_DECODER_TYPE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type DcrumDecoderObservation struct {
}

type DcrumDecoderParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type DimensionalRuleObservation struct {
}

type DimensionalRuleParameters struct {

	// The target of the rule. Possible values are
	// - `ANY`
	// - `LOG`
	// - `METRIC`
	// +kubebuilder:validation:Required
	AppliesTo *string `json:"appliesTo" tf:"applies_to,omitempty"`

	// A list of conditions for the management zone. The management zone applies only if **all** conditions are fulfilled
	// +kubebuilder:validation:Optional
	Condition []ConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// The rule is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type DynamicKeyObservation struct {
}

type DynamicKeyParameters struct {

	// The actual key of the custom metadata
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
	// +kubebuilder:validation:Required
	Source *string `json:"source" tf:"source,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type EntityIDComparisonObservation struct {
}

type EntityIDComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be ENTITY_ID
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type EntityObservation struct {
}

type EntityParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type EntitySelectorBasedRuleObservation struct {
}

type EntitySelectorBasedRuleParameters struct {

	// The rule is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The entity selector string, by which the entities are selected
	// +kubebuilder:validation:Optional
	Selector *string `json:"selector,omitempty" tf:"selector,omitempty"`

	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type HostTechObservation struct {
}

type HostTechParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value []ValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type HypervisorObservation struct {
}

type HypervisorParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type HypervisorTypeComparisionObservation struct {
}

type HypervisorTypeComparisionParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be HYPERVISOR_TYPE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IndexedNameComparisonObservation struct {
}

type IndexedNameComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be INDEXED_NAME
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IndexedNameObservation struct {
}

type IndexedNameParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IndexedStringComparisonObservation struct {
}

type IndexedStringComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be INDEXED_STRING
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IndexedStringObservation struct {
}

type IndexedStringParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IndexedTagComparisonObservation struct {
}

type IndexedTagComparisonParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be INDEXED_TAG
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// Tag of a Dynatrace entity
	// +kubebuilder:validation:Optional
	Value []IndexedTagComparisonValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type IndexedTagComparisonValueObservation struct {
}

type IndexedTagComparisonValueParameters struct {

	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	// +kubebuilder:validation:Required
	Context *string `json:"context" tf:"context,omitempty"`

	// The key of the tag. Custom tags have the tag value here
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value of the tag. Not applicable to custom tags
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IndexedTagObservation struct {
}

type IndexedTagParameters struct {

	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// Tag of a Dynatrace entity
	// +kubebuilder:validation:Optional
	Value []IndexedTagValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type IndexedTagValueObservation struct {
}

type IndexedTagValueParameters struct {

	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	// +kubebuilder:validation:Required
	Context *string `json:"context" tf:"context,omitempty"`

	// The key of the tag. Custom tags have the tag value here
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value of the tag. Not applicable to custom tags
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IntegerComparisonObservation struct {
}

type IntegerComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be INTEGER
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`
}

type IntegerObservation struct {
}

type IntegerParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`
}

type IpaddressComparisonObservation struct {
}

type IpaddressComparisonParameters struct {

	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be IP_ADDRESS
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type IpaddressObservation struct {
}

type IpaddressParameters struct {

	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type KeyObservation struct {
}

type KeyParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// Defines the actual set of fields depending on the value
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type MetadataObservation struct {
}

type MetadataParameters struct {

	// Dynatrace server version
	// +kubebuilder:validation:Optional
	ClusterVersion *string `json:"clusterVersion,omitempty" tf:"cluster_version,omitempty"`

	// A Sorted list of the version numbers of the configuration
	// +kubebuilder:validation:Optional
	ConfigurationVersions []*float64 `json:"configurationVersions,omitempty" tf:"configuration_versions,omitempty"`

	// A Sorted list of the version numbers of the configuration
	// +kubebuilder:validation:Optional
	CurrentConfigurationVersions []*string `json:"currentConfigurationVersions,omitempty" tf:"current_configuration_versions,omitempty"`
}

type MobilePlatformComparisonObservation struct {
}

type MobilePlatformComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be MOBILE_PLATFORM
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MobilePlatformObservation struct {
}

type MobilePlatformParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OsArchObservation struct {
}

type OsArchParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OsTypeObservation struct {
}

type OsTypeParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OsarchitectureComparisonObservation struct {
}

type OsarchitectureComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be OS_ARCHITECTURE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OstypeComparisonObservation struct {
}

type OstypeComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be OS_TYPE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PaasTypeComparisonObservation struct {
}

type PaasTypeComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be PAAS_TYPE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PaasTypeObservation struct {
}

type PaasTypeParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ProcessMetadataConditionKeyObservation struct {
}

type ProcessMetadataConditionKeyParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
	// +kubebuilder:validation:Required
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key,omitempty"`

	// if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type ProcessMetadataObservation struct {
}

type ProcessMetadataParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
	// +kubebuilder:validation:Required
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type RulesObservation struct {
}

type RulesParameters struct {

	// A list of matching rules for the management zone. The management zone applies only if **all** conditions are fulfilled
	// +kubebuilder:validation:Optional
	Conditions []ConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// The rule is enabled (`true`) or disabled (`false`)
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// How to apply the management zone to underlying entities:
	// - `SERVICE_TO_HOST_LIKE`: Apply to underlying hosts of matching services
	// - `SERVICE_TO_PROCESS_GROUP_LIKE`: Apply to underlying process groups of matching services
	// - `PROCESS_GROUP_TO_HOST`: Apply to underlying hosts of matching process groups
	// - `PROCESS_GROUP_TO_SERVICE`: Apply to all services provided by matching process groups
	// - `HOST_TO_PROCESS_GROUP_INSTANCE`: Apply to processes running on matching hosts
	// - `CUSTOM_DEVICE_GROUP_TO_CUSTOM_DEVICE`: Apply to custom devices in matching custom device groups
	// - `AZURE_TO_PG`: Apply to process groups connected to matching Azure entities
	// - `AZURE_TO_SERVICE`: Apply to services provided by matching Azure entities
	// +kubebuilder:validation:Optional
	PropagationTypes []*string `json:"propagationTypes,omitempty" tf:"propagation_types,omitempty"`

	// The type of Dynatrace entities the management zone can be applied to
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type ServiceTopologyComparisonObservation struct {
}

type ServiceTopologyComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be SERVICE_TOPOLOGY
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ServiceTopologyObservation struct {
}

type ServiceTopologyParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ServiceTypeComparisonObservation struct {
}

type ServiceTypeComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be SERVICE_TYPE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ServiceTypeObservation struct {
}

type ServiceTypeParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SimpleHostTechComparisonObservation struct {
}

type SimpleHostTechComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be SIMPLE_HOST_TECH
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value []SimpleHostTechComparisonValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type SimpleHostTechComparisonValueObservation struct {
}

type SimpleHostTechComparisonValueParameters struct {

	// Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// Non-predefined technology, use for custom technologies
	// +kubebuilder:validation:Optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type,omitempty"`
}

type SimpleTechComparisonObservation struct {
}

type SimpleTechComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be SIMPLE_TECH
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value []SimpleTechComparisonValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type SimpleTechComparisonValueObservation struct {
}

type SimpleTechComparisonValueParameters struct {

	// Predefined technology, if technology is not predefined, then the verbatim type must be set.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// Non-predefined technology, use for custom technologies
	// +kubebuilder:validation:Optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type,omitempty"`
}

type StringComparisonObservation struct {
}

type StringComparisonParameters struct {

	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be STRING
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type StringConditionKeyObservation struct {
}

type StringConditionKeyParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
	// - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
	// - `AMAZON_ECR_IMAGE_REGION`
	// - `AMAZON_LAMBDA_FUNCTION_NAME`
	// - `AMAZON_REGION`
	// - `APACHE_CONFIG_PATH`
	// - `APACHE_SPARK_MASTER_IP_ADDRESS`
	// - `ASP_DOT_NET_CORE_APPLICATION_PATH`
	// - `AWS_ECS_CLUSTER`
	// - `AWS_ECS_CONTAINERNAME`
	// - `AWS_ECS_FAMILY`
	// - `AWS_ECS_REVISION`
	// - `CASSANDRA_CLUSTER_NAME`
	// - `CATALINA_BASE`
	// - `CATALINA_HOME`
	// - `CLOUD_FOUNDRY_APP_ID`
	// - `CLOUD_FOUNDRY_APP_NAME`
	// - `CLOUD_FOUNDRY_INSTANCE_INDEX`
	// - `CLOUD_FOUNDRY_SPACE_ID`
	// - `CLOUD_FOUNDRY_SPACE_NAME`
	// - `COLDFUSION_JVM_CONFIG_FILE`
	// - `COLDFUSION_SERVICE_NAME`
	// - `COMMAND_LINE_ARGS`
	// - `DOTNET_COMMAND`
	// - `DOTNET_COMMAND_PATH`
	// - `DYNATRACE_CLUSTER_ID`
	// - `DYNATRACE_NODE_ID`
	// - `ELASTICSEARCH_CLUSTER_NAME`
	// - `ELASTICSEARCH_NODE_NAME`
	// - `EQUINOX_CONFIG_PATH`
	// - `EXE_NAME`
	// - `EXE_PATH`
	// - `GLASS_FISH_DOMAIN_NAME`
	// - `GLASS_FISH_INSTANCE_NAME`
	// - `GOOGLE_APP_ENGINE_INSTANCE`
	// - `GOOGLE_APP_ENGINE_SERVICE`
	// - `GOOGLE_CLOUD_PROJECT`
	// - `HYBRIS_BIN_DIRECTORY`
	// - `HYBRIS_CONFIG_DIRECTORY`
	// - `HYBRIS_DATA_DIRECTORY`
	// - `IBM_CICS_REGION`
	// - `IBM_CTG_NAME`
	// - `IBM_IMS_CONNECT_REGION`
	// - `IBM_IMS_CONTROL_REGION`
	// - `IBM_IMS_MESSAGE_PROCESSING_REGION`
	// - `IBM_IMS_SOAP_GW_NAME`
	// - `IBM_INTEGRATION_NODE_NAME`
	// - `IBM_INTEGRATION_SERVER_NAME`
	// - `IIS_APP_POOL`
	// - `IIS_ROLE_NAME`
	// - `JAVA_JAR_FILE`
	// - `JAVA_JAR_PATH`
	// - `JAVA_MAIN_CLASS`
	// - `JAVA_MAIN_MODULE`
	// - `JBOSS_HOME`
	// - `JBOSS_MODE`
	// - `JBOSS_SERVER_NAME`
	// - `KUBERNETES_BASE_POD_NAME`
	// - `KUBERNETES_CONTAINER_NAME`
	// - `KUBERNETES_FULL_POD_NAME`
	// - `KUBERNETES_NAMESPACE`
	// - `KUBERNETES_POD_UID`
	// - `MSSQL_INSTANCE_NAME`
	// - `NODE_JS_APP_BASE_DIRECTORY`
	// - `NODE_JS_APP_NAME`
	// - `NODE_JS_SCRIPT_NAME`
	// - `ORACLE_SID`
	// - `PG_ID_CALC_INPUT_KEY_LINKAGE`
	// - `PHP_SCRIPT_PATH`
	// - `PHP_WORKING_DIRECTORY`
	// - `RUBY_APP_ROOT_PATH`
	// - `RUBY_SCRIPT_PATH`
	// - `RULE_RESULT`
	// - `SOFTWAREAG_INSTALL_ROOT`
	// - `SOFTWAREAG_PRODUCTPROPNAME`
	// - `SPRINGBOOT_APP_NAME`
	// - `SPRINGBOOT_PROFILE_NAME`
	// - `SPRINGBOOT_STARTUP_CLASS`
	// - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
	// - `TIBCO_BUSINESSWORKS_CE_VERSION`
	// - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
	// - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
	// - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
	// - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
	// - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
	// - `TIBCO_BUSINESS_WORKS_HOME`
	// - `VARNISH_INSTANCE_NAME`
	// - `WEB_LOGIC_CLUSTER_NAME`
	// - `WEB_LOGIC_DOMAIN_NAME`
	// - `WEB_LOGIC_HOME`
	// - `WEB_LOGIC_NAME`
	// - `WEB_SPHERE_CELL_NAME`
	// - `WEB_SPHERE_CLUSTER_NAME`
	// - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
	// +kubebuilder:validation:Required
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key,omitempty"`

	// if specified, needs to be `STRING`
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type StringKeyObservation struct {
}

type StringKeyParameters struct {

	// The attribute to be used for comparision
	// +kubebuilder:validation:Required
	Attribute *string `json:"attribute" tf:"attribute,omitempty"`

	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
	// - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
	// - `AMAZON_ECR_IMAGE_REGION`
	// - `AMAZON_LAMBDA_FUNCTION_NAME`
	// - `AMAZON_REGION`
	// - `APACHE_CONFIG_PATH`
	// - `APACHE_SPARK_MASTER_IP_ADDRESS`
	// - `ASP_DOT_NET_CORE_APPLICATION_PATH`
	// - `AWS_ECS_CLUSTER`
	// - `AWS_ECS_CONTAINERNAME`
	// - `AWS_ECS_FAMILY`
	// - `AWS_ECS_REVISION`
	// - `CASSANDRA_CLUSTER_NAME`
	// - `CATALINA_BASE`
	// - `CATALINA_HOME`
	// - `CLOUD_FOUNDRY_APP_ID`
	// - `CLOUD_FOUNDRY_APP_NAME`
	// - `CLOUD_FOUNDRY_INSTANCE_INDEX`
	// - `CLOUD_FOUNDRY_SPACE_ID`
	// - `CLOUD_FOUNDRY_SPACE_NAME`
	// - `COLDFUSION_JVM_CONFIG_FILE`
	// - `COLDFUSION_SERVICE_NAME`
	// - `COMMAND_LINE_ARGS`
	// - `DOTNET_COMMAND`
	// - `DOTNET_COMMAND_PATH`
	// - `DYNATRACE_CLUSTER_ID`
	// - `DYNATRACE_NODE_ID`
	// - `ELASTICSEARCH_CLUSTER_NAME`
	// - `ELASTICSEARCH_NODE_NAME`
	// - `EQUINOX_CONFIG_PATH`
	// - `EXE_NAME`
	// - `EXE_PATH`
	// - `GLASS_FISH_DOMAIN_NAME`
	// - `GLASS_FISH_INSTANCE_NAME`
	// - `GOOGLE_APP_ENGINE_INSTANCE`
	// - `GOOGLE_APP_ENGINE_SERVICE`
	// - `GOOGLE_CLOUD_PROJECT`
	// - `HYBRIS_BIN_DIRECTORY`
	// - `HYBRIS_CONFIG_DIRECTORY`
	// - `HYBRIS_DATA_DIRECTORY`
	// - `IBM_CICS_REGION`
	// - `IBM_CTG_NAME`
	// - `IBM_IMS_CONNECT_REGION`
	// - `IBM_IMS_CONTROL_REGION`
	// - `IBM_IMS_MESSAGE_PROCESSING_REGION`
	// - `IBM_IMS_SOAP_GW_NAME`
	// - `IBM_INTEGRATION_NODE_NAME`
	// - `IBM_INTEGRATION_SERVER_NAME`
	// - `IIS_APP_POOL`
	// - `IIS_ROLE_NAME`
	// - `JAVA_JAR_FILE`
	// - `JAVA_JAR_PATH`
	// - `JAVA_MAIN_CLASS`
	// - `JAVA_MAIN_MODULE`
	// - `JBOSS_HOME`
	// - `JBOSS_MODE`
	// - `JBOSS_SERVER_NAME`
	// - `KUBERNETES_BASE_POD_NAME`
	// - `KUBERNETES_CONTAINER_NAME`
	// - `KUBERNETES_FULL_POD_NAME`
	// - `KUBERNETES_NAMESPACE`
	// - `KUBERNETES_POD_UID`
	// - `MSSQL_INSTANCE_NAME`
	// - `NODE_JS_APP_BASE_DIRECTORY`
	// - `NODE_JS_APP_NAME`
	// - `NODE_JS_SCRIPT_NAME`
	// - `ORACLE_SID`
	// - `PG_ID_CALC_INPUT_KEY_LINKAGE`
	// - `PHP_SCRIPT_PATH`
	// - `PHP_WORKING_DIRECTORY`
	// - `RUBY_APP_ROOT_PATH`
	// - `RUBY_SCRIPT_PATH`
	// - `RULE_RESULT`
	// - `SOFTWAREAG_INSTALL_ROOT`
	// - `SOFTWAREAG_PRODUCTPROPNAME`
	// - `SPRINGBOOT_APP_NAME`
	// - `SPRINGBOOT_PROFILE_NAME`
	// - `SPRINGBOOT_STARTUP_CLASS`
	// - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
	// - `TIBCO_BUSINESSWORKS_CE_VERSION`
	// - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
	// - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
	// - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
	// - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
	// - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
	// - `TIBCO_BUSINESS_WORKS_HOME`
	// - `VARNISH_INSTANCE_NAME`
	// - `WEB_LOGIC_CLUSTER_NAME`
	// - `WEB_LOGIC_DOMAIN_NAME`
	// - `WEB_LOGIC_HOME`
	// - `WEB_LOGIC_NAME`
	// - `WEB_SPHERE_CELL_NAME`
	// - `WEB_SPHERE_CLUSTER_NAME`
	// - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
	// +kubebuilder:validation:Required
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

type StringObservation struct {
}

type StringParameters struct {

	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SyntheticEngineObservation struct {
}

type SyntheticEngineParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are CLASSIC and CUSTOM
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SyntheticEngineTypeComparisonObservation struct {
}

type SyntheticEngineTypeComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be SYNTHETIC_ENGINE_TYPE
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to. Possible values are CLASSIC and CUSTOM
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagComparisonObservation struct {
}

type TagComparisonParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// if specified, needs to be TAG
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// Tag of a Dynatrace entity
	// +kubebuilder:validation:Optional
	Value []TagComparisonValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type TagComparisonValueObservation struct {
}

type TagComparisonValueParameters struct {

	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	// +kubebuilder:validation:Required
	Context *string `json:"context" tf:"context,omitempty"`

	// The key of the tag. Custom tags have the tag value here
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value of the tag. Not applicable to custom tags
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagObservation struct {
}

type TagParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// Tag of a Dynatrace entity
	// +kubebuilder:validation:Optional
	Value []TagValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type TagValueObservation struct {
}

type TagValueParameters struct {

	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	// +kubebuilder:validation:Required
	Context *string `json:"context" tf:"context,omitempty"`

	// The key of the tag. Custom tags have the tag value here
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value of the tag. Not applicable to custom tags
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type TechObservation struct {
}

type TechParameters struct {

	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// The value to compare to
	// +kubebuilder:validation:Optional
	Value []TechValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type TechValueObservation struct {
}

type TechValueParameters struct {

	// Predefined technology, if technology is not predefined, then the verbatim type must be set.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// Non-predefined technology, use for custom technologies
	// +kubebuilder:validation:Optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type,omitempty"`
}

type ValueObservation struct {
}

type ValueParameters struct {

	// Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Any attributes that aren't yet supported by this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`

	// Non-predefined technology, use for custom technologies
	// +kubebuilder:validation:Optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type,omitempty"`
}

type ZoneObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ZoneParameters struct {

	// The description of the management zone
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// A list of dimensional data rules for management zone usage. If several rules are specified, the `or` logic applies
	// +kubebuilder:validation:Optional
	DimensionalRule []DimensionalRuleParameters `json:"dimensionalRule,omitempty" tf:"dimensional_rule,omitempty"`

	// A list of entity-selector based rules for management zone usage. If several rules are specified, the `or` logic applies
	// +kubebuilder:validation:Optional
	EntitySelectorBasedRule []EntitySelectorBasedRuleParameters `json:"entitySelectorBasedRule,omitempty" tf:"entity_selector_based_rule,omitempty"`

	// `metadata` exists for backwards compatibility but shouldn't get specified anymore
	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// The name of the management zone
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// A list of rules for management zone usage.  Each rule is evaluated independently of all other rules
	// +kubebuilder:validation:Optional
	Rules []RulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +kubebuilder:validation:Optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns,omitempty"`
}

// ZoneSpec defines the desired state of Zone
type ZoneSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ZoneParameters `json:"forProvider"`
}

// ZoneStatus defines the observed state of Zone.
type ZoneStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ZoneObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Zone is the Schema for the Zones API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,dynatracejet}
type Zone struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ZoneSpec   `json:"spec"`
	Status            ZoneStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ZoneList contains a list of Zones
type ZoneList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Zone `json:"items"`
}

// Repository type metadata.
var (
	Zone_Kind             = "Zone"
	Zone_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Zone_Kind}.String()
	Zone_KindAPIVersion   = Zone_Kind + "." + CRDGroupVersion.String()
	Zone_GroupVersionKind = CRDGroupVersion.WithKind(Zone_Kind)
)

func init() {
	SchemeBuilder.Register(&Zone{}, &ZoneList{})
}
